---
phase: 08-per-group-overrides-and-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/db.ts
  - src/config-loader.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "A group with executionMode 'host' in the database resolves to host mode even when global config is 'container'"
    - "A group without executionMode in the database inherits the global config setting"
    - "Startup blocks with a clear error if any registered group has executionMode 'host' but hostSecurity is missing from config"
    - "Startup prints a boxed ASCII banner when at least one group will run in host mode"
    - "Container system check only runs when at least one group needs container mode"
    - "Per-group mode is resolved fresh at message-processing time (not cached at startup)"
  artifacts:
    - path: "src/types.ts"
      provides: "RegisteredGroup.executionMode optional field"
      contains: "executionMode"
    - path: "src/db.ts"
      provides: "execution_mode column migration and getter/setter support"
      contains: "execution_mode"
    - path: "src/config-loader.ts"
      provides: "resolveExecutionMode() function and printHostModeBanner()"
      exports: ["resolveExecutionMode"]
    - path: "src/index.ts"
      provides: "Startup validation, conditional container check, per-group routing in runAgent and processGroupMessages"
      contains: "resolveExecutionMode"
  key_links:
    - from: "src/config-loader.ts"
      to: "src/types.ts"
      via: "resolveExecutionMode uses RegisteredGroup.executionMode"
      pattern: "group\\.executionMode"
    - from: "src/index.ts"
      to: "src/config-loader.ts"
      via: "runAgent calls resolveExecutionMode"
      pattern: "resolveExecutionMode"
    - from: "src/db.ts"
      to: "src/types.ts"
      via: "getRegisteredGroup and setRegisteredGroup handle executionMode field"
      pattern: "execution_mode"
---

<objective>
Add per-group execution mode overrides: data layer (type + DB), resolution function, startup validation/banner, and per-group routing in the main message and task pipelines.

Purpose: This is the core of Phase 8 -- enabling individual WhatsApp groups to run in a different execution mode than the global config. The safety-first approach blocks startup when security config is missing for host-mode groups. The startup banner provides clear visibility into which groups have macOS access.

Output: RegisteredGroup gains an optional `executionMode` field persisted in SQLite, `resolveExecutionMode(group)` resolves per-group or falls back to global, startup validates security requirements and prints a host mode banner, and `runAgent()`/`runTask()` use per-group mode instead of global.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types.ts
@src/db.ts
@src/config-loader.ts
@src/index.ts
@src/host-runner.ts
@src/task-scheduler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add executionMode to RegisteredGroup type, DB, and resolution function</name>
  <files>src/types.ts, src/db.ts, src/config-loader.ts</files>
  <action>
**src/types.ts:**
Add an optional `executionMode` field to the `RegisteredGroup` interface:
```typescript
executionMode?: 'container' | 'host'; // Per-group override; undefined = inherit global
```
Place it after `channelType`.

**src/db.ts:**
1. Add a DB migration for `execution_mode` column in `initDatabase()`, following the existing pattern (try/catch ALTER TABLE):
```typescript
try {
  db.exec(`ALTER TABLE registered_groups ADD COLUMN execution_mode TEXT DEFAULT NULL`);
} catch { /* column already exists */ }
```
Place after the `channel_type` migration.

2. Update `getRegisteredGroup()` to read `execution_mode` from the row and map it to `executionMode` on the returned object. The DB column stores `'host'` or `'container'` as TEXT, or NULL for inherit. Map NULL to `undefined`.

3. Update `getAllRegisteredGroups()` the same way -- read `execution_mode` from each row and set `executionMode` on the result object.

4. Update `setRegisteredGroup()` to persist `group.executionMode` into the `execution_mode` column. Add it to the INSERT OR REPLACE statement. Store `null` when `undefined`.

**src/config-loader.ts:**
Add and export a `resolveExecutionMode` function at the bottom of the file, AFTER the `config` export:
```typescript
import type { RegisteredGroup } from './types.js';

export type ExecutionMode = 'container' | 'host';

/**
 * Resolve the execution mode for a specific group.
 * Per-group override takes precedence, otherwise falls back to global config.
 * Called at message-processing time (not cached) to support config reloading.
 */
export function resolveExecutionMode(group: RegisteredGroup): ExecutionMode {
  return group.executionMode ?? config.executionMode;
}
```

Note: The import of RegisteredGroup must be a `type` import to avoid circular dependencies (types.ts has no imports from config-loader). Place the import at the top of config-loader.ts with the other imports.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles with no errors. Grep for `executionMode` in types.ts, `execution_mode` in db.ts, and `resolveExecutionMode` in config-loader.ts to confirm all three changes are present.
  </verify>
  <done>
RegisteredGroup has optional executionMode field. DB has execution_mode column with NULL default. getRegisteredGroup, getAllRegisteredGroups, and setRegisteredGroup handle the field. resolveExecutionMode() is exported from config-loader.ts and returns group-level override or global fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Startup validation, banner, conditional container check, and per-group routing</name>
  <files>src/index.ts, src/task-scheduler.ts</files>
  <action>
All changes below reference the current source. Line numbers are from the unmodified files.

---

**1. src/index.ts -- Import change (line 14)**

Replace the existing import on line 14:
```typescript
// OLD (line 14):
import { config } from './config-loader.js';

// NEW:
import { config, resolveExecutionMode } from './config-loader.js';
```

---

**2. src/index.ts -- Rewrite `main()` function (lines 1008-1017)**

The current `main()` starts with the container check, then initDatabase, then loadState. The new version moves the container check AFTER loadState so we can inspect registered groups, and adds validation + banner between loadState and the container check.

Replace the entire `main()` body from line 1008 to line 1017 (just before the `// Graceful shutdown handlers` comment):

```typescript
// OLD (lines 1008-1017):
async function main(): Promise<void> {
  if (config.executionMode === 'container') {
    ensureContainerSystemRunning();
  } else {
    logger.info({ executionMode: config.executionMode }, 'Skipping container system check (non-container mode)');
  }
  initDatabase();
  logger.info('Database initialized');
  loadState();
  logger.info({ executionMode: config.executionMode }, 'Execution mode');

// NEW:
async function main(): Promise<void> {
  initDatabase();
  logger.info('Database initialized');
  loadState();
  logger.info({ executionMode: config.executionMode }, 'Execution mode (global default)');

  // Determine which execution modes are needed across all groups
  const allGroups = Object.values(registeredGroups);
  const needsHost = allGroups.some(g => resolveExecutionMode(g) === 'host') || (allGroups.length === 0 && config.executionMode === 'host');
  const needsContainer = allGroups.some(g => resolveExecutionMode(g) === 'container') || (allGroups.length === 0 && config.executionMode === 'container');

  // Safety-first: block startup if any group needs host mode but hostSecurity is missing
  if (needsHost && !config.hostSecurity) {
    console.error('\n' + '='.repeat(66));
    console.error('  FATAL: Host mode requires hostSecurity configuration');
    console.error('='.repeat(66));
    console.error('');
    console.error('  Groups configured for host mode:');
    const hostGroups = allGroups.filter(g => resolveExecutionMode(g) === 'host');
    if (hostGroups.length > 0) {
      for (const g of hostGroups) {
        console.error(`    - ${g.name} (${g.folder})`);
      }
    } else {
      console.error('    - (global default: host mode)');
    }
    console.error('');
    console.error('  Add "hostSecurity" to nanoclaw.config.jsonc:');
    console.error('    "hostSecurity": { "sandbox": true }');
    console.error('');
    console.error('='.repeat(66) + '\n');
    process.exit(1);
  }

  // Startup banner: warn when any group will run with full macOS access
  if (needsHost) {
    const hostGroups = allGroups.filter(g => resolveExecutionMode(g) === 'host');
    const sandboxEnabled = config.hostSecurity?.sandbox !== false;
    const toolCount = config.hostSecurity?.tools?.length;

    console.error('');
    console.error('╔' + '═'.repeat(64) + '╗');
    console.error('║  HOST MODE ACTIVE -- Agents have macOS access' + ' '.repeat(18) + '║');
    console.error('╠' + '═'.repeat(64) + '╣');
    console.error('║' + ' '.repeat(64) + '║');
    if (hostGroups.length > 0 && hostGroups.length < allGroups.length) {
      // Mixed mode: some groups in host, some in container
      console.error(('║  Host groups: ' + hostGroups.map(g => g.name).join(', ')).padEnd(65) + '║');
      const containerGroups = allGroups.filter(g => resolveExecutionMode(g) === 'container');
      console.error(('║  Container groups: ' + containerGroups.map(g => g.name).join(', ')).padEnd(65) + '║');
    } else if (allGroups.length > 0) {
      console.error(('║  All ' + allGroups.length + ' group(s) running in host mode').padEnd(65) + '║');
    } else {
      console.error('║  Global default: host mode (no groups registered)'.padEnd(65) + '║');
    }
    console.error(('║  Sandbox: ' + (sandboxEnabled ? 'ON (non-main)' : 'OFF')).padEnd(65) + '║');
    if (toolCount) {
      console.error(('║  Tool restrictions: ' + toolCount + ' tools allowed (non-main)').padEnd(65) + '║');
    }
    console.error('║' + ' '.repeat(64) + '║');
    console.error('╚' + '═'.repeat(64) + '╝');
    console.error('');
  }

  // Conditional container system check (only when at least one group needs it)
  if (needsContainer) {
    try {
      ensureContainerSystemRunning();
    } catch (err) {
      if (needsHost) {
        // Mixed mode: container system down but host groups can still work
        logger.warn({ err }, 'Container system unavailable -- container-mode groups will get errors, host-mode groups will work');
      } else {
        throw err; // All groups need containers, can't start
      }
    }
  } else {
    logger.info('Skipping container system check (no groups need container mode)');
  }
```

Everything after this point in `main()` (graceful shutdown, Slack connect, WhatsApp connect) stays unchanged.

---

**3. src/index.ts -- Per-group routing in `runAgent()` (lines 321-338)**

Replace the `config.executionMode === 'host'` ternary with per-group resolution. The full old/new for lines 321-338:

```typescript
// OLD (lines 321-338):
    const output = config.executionMode === 'host'
      ? await runHostAgent(
          group,
          agentInput,
          (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
          {
            hostSecurity: config.hostSecurity,
            mainGroupJid: Object.entries(registeredGroups).find(
              ([, g]) => g.folder === MAIN_GROUP_FOLDER,
            )?.[0],
            mainGroupFolder: MAIN_GROUP_FOLDER,
          },
        )
      : await runContainerAgent(
          group,
          agentInput,
          (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
        );

// NEW:
    const mode = resolveExecutionMode(group);
    const output = mode === 'host'
      ? await runHostAgent(
          group,
          agentInput,
          (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
          {
            hostSecurity: config.hostSecurity,
            mainGroupJid: Object.entries(registeredGroups).find(
              ([, g]) => g.folder === MAIN_GROUP_FOLDER,
            )?.[0],
            mainGroupFolder: MAIN_GROUP_FOLDER,
          },
        )
      : await runContainerAgent(
          group,
          agentInput,
          (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
        );
```

---

**4. src/index.ts -- Mode hint in `processGroupMessages()` (lines 265-267)**

Replace the existing sendMessage block with a mode-aware prefix:

```typescript
// OLD (lines 265-267):
  if (response.outputType === 'message' && response.userMessage) {
    await sendMessage(chatJid, `${ASSISTANT_NAME}: ${response.userMessage}`);
  }

// NEW:
  if (response.outputType === 'message' && response.userMessage) {
    const mode = resolveExecutionMode(group);
    const prefix = mode === 'host' ? `${ASSISTANT_NAME} [host]` : ASSISTANT_NAME;
    await sendMessage(chatJid, `${prefix}: ${response.userMessage}`);
  }
```

---

**5. src/index.ts -- `processTaskIpc()` data type + register_group case**

5a. Add `executionMode` to the data type annotation (insert after `containerConfig` on line 556):

```typescript
// OLD (lines 555-557):
    containerConfig?: RegisteredGroup['containerConfig'];
  },
  sourceGroup: string, // Verified identity from IPC directory

// NEW:
    containerConfig?: RegisteredGroup['containerConfig'];
    executionMode?: 'container' | 'host';
  },
  sourceGroup: string, // Verified identity from IPC directory
```

5b. Pass `executionMode` through in the `register_group` case (lines 742-748):

```typescript
// OLD (lines 742-748):
      if (data.jid && data.name && data.folder && data.trigger) {
        registerGroup(data.jid, {
          name: data.name,
          folder: data.folder,
          trigger: data.trigger,
          added_at: new Date().toISOString(),
          containerConfig: data.containerConfig,
        });

// NEW:
      if (data.jid && data.name && data.folder && data.trigger) {
        registerGroup(data.jid, {
          name: data.name,
          folder: data.folder,
          trigger: data.trigger,
          added_at: new Date().toISOString(),
          containerConfig: data.containerConfig,
          executionMode: data.executionMode,
        });
```

---

**6. src/task-scheduler.ts -- Import change (line 13)**

```typescript
// OLD (line 13):
import { config } from './config-loader.js';

// NEW:
import { config, resolveExecutionMode } from './config-loader.js';
```

---

**7. src/task-scheduler.ts -- Per-group routing in `runTask()` (lines 112-123)**

```typescript
// OLD (lines 112-123):
    const output = config.executionMode === 'host'
      ? await runHostAgent(
          group,
          agentInput,
          (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
          securityCtx,
        )
      : await runContainerAgent(
          group,
          agentInput,
          (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
        );

// NEW:
    const mode = resolveExecutionMode(group);
    const output = mode === 'host'
      ? await runHostAgent(
          group,
          agentInput,
          (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
          securityCtx,
        )
      : await runContainerAgent(
          group,
          agentInput,
          (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
        );
```

---

**8. src/task-scheduler.ts -- Mode hint in `runTask()` sendMessage (lines 128-129)**

```typescript
// OLD (lines 128-129):
      if (output.result.outputType === 'message' && output.result.userMessage) {
        await deps.sendMessage(task.chat_jid, `${ASSISTANT_NAME}: ${output.result.userMessage}`);

// NEW:
      if (output.result.outputType === 'message' && output.result.userMessage) {
        const taskMode = resolveExecutionMode(group);
        const prefix = taskMode === 'host' ? `${ASSISTANT_NAME} [host]` : ASSISTANT_NAME;
        await deps.sendMessage(task.chat_jid, `${prefix}: ${output.result.userMessage}`);
```

---

**IMPORTANT -- what NOT to change:**
- Do NOT change `ensureContainerSystemRunning()` itself -- only the call site in `main()`
- Do NOT change the host-runner or container-runner internals
- Do NOT change the agent-runner code
- Do NOT modify the config schema (executionMode stays on RegisteredGroup, not in config file)
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles. Grep for `resolveExecutionMode` in index.ts and task-scheduler.ts. Grep for `HOST MODE ACTIVE` in index.ts to confirm banner. Grep for `needsContainer` and `needsHost` to confirm conditional container check.
  </verify>
  <done>
Startup validates hostSecurity is present when host mode needed. Boxed ASCII banner shows host-mode groups, sandbox status, and tool restrictions. Container system check only runs when needed, and container failures don't prevent host-mode groups from working in mixed mode. runAgent() and runTask() use resolveExecutionMode(group) for per-group routing. register_group IPC accepts optional executionMode. Host-mode responses include `[host]` tag.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `npm run build:agent` passes (agent-runner unchanged but verify no regressions)
3. Grep confirms `resolveExecutionMode` is called in both index.ts and task-scheduler.ts
4. Grep confirms `execution_mode` column migration exists in db.ts
5. Grep confirms `HOST MODE ACTIVE` banner string exists in index.ts
6. Grep confirms `hostSecurity` validation with process.exit(1) in index.ts
</verification>

<success_criteria>
- RegisteredGroup type has optional executionMode field
- SQLite schema has execution_mode column with NULL default
- resolveExecutionMode() returns group-level override or global fallback
- Startup blocks if host mode needed but hostSecurity missing
- Boxed ASCII banner appears when any group runs in host mode
- Container system check conditional on whether any group needs it
- Mixed mode: container failure doesn't block host-mode groups
- runAgent() uses per-group mode, not global
- runTask() uses per-group mode, not global
- register_group IPC accepts optional executionMode
- Host-mode responses tagged with [host]
</success_criteria>

<output>
After completion, create `.planning/phases/08-per-group-overrides-and-integration/08-01-SUMMARY.md`
</output>
