---
phase: 06-mcp-server-configuration-and-filtering
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/container-runner.ts
  - src/host-runner.ts
  - container/agent-runner/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent startup only loads MCP servers whose modes include the current execution mode"
    - "Startup logs list which MCP servers are active and which were filtered out due to mode incompatibility"
    - "NanoClaw IPC MCP server is always injected separately, not affected by config servers"
    - "If all configured servers are filtered out, agent continues with just the IPC MCP server"
    - "MCP server failure is non-fatal -- agent operates even if a configured server fails to start"
  artifacts:
    - path: "src/container-runner.ts"
      provides: "ContainerInput extended with mcpServers field"
      contains: "mcpServers"
    - path: "src/host-runner.ts"
      provides: "Passes filtered MCP servers from config to ContainerInput"
      contains: "mcpServers"
    - path: "container/agent-runner/src/index.ts"
      provides: "Merges config MCP servers with IPC MCP, logs active/filtered"
      contains: "filterMcpServersByMode"
  key_links:
    - from: "src/host-runner.ts"
      to: "src/config-loader.ts"
      via: "reads config.mcpServers and passes to ContainerInput"
      pattern: "config\\.mcpServers|mcpServers"
    - from: "src/host-runner.ts"
      to: "container/agent-runner/src/index.ts"
      via: "mcpServers field in ContainerInput stdin JSON"
      pattern: "mcpServers"
    - from: "container/agent-runner/src/index.ts"
      to: "container/agent-runner/src/mcp-filter.ts"
      via: "import filterMcpServersByMode"
      pattern: "filterMcpServersByMode"
    - from: "container/agent-runner/src/index.ts"
      to: "query() mcpServers option"
      via: "spread operator merging IPC + config servers"
      pattern: "nanoclaw.*ipcMcp.*\\.\\.\\..*mcpServers|mcpServers.*nanoclaw"
---

<objective>
Wire filtered MCP servers through the runner pipeline so they reach the Claude Agent SDK's query() function alongside the always-injected IPC MCP server.

Purpose: Completes the end-to-end flow: config defines servers with mode tags -> runners filter by current mode -> agent-runner receives pre-filtered servers -> query() gets them merged with IPC MCP. This makes MCP-01, MCP-02, MCP-03, and MCP-05 requirements fully operational.

Output: ContainerInput carries mcpServers, both runners pass them through, agent-runner merges with IPC MCP and logs active/filtered servers at startup.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-mcp-server-configuration-and-filtering/06-CONTEXT.md
@.planning/phases/06-mcp-server-configuration-and-filtering/06-RESEARCH.md
@.planning/phases/06-mcp-server-configuration-and-filtering/06-01-SUMMARY.md
@src/container-runner.ts
@src/host-runner.ts
@src/index.ts
@container/agent-runner/src/index.ts
@container/agent-runner/src/mcp-filter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ContainerInput and pass MCP servers from runners</name>
  <files>src/container-runner.ts, src/host-runner.ts, src/index.ts</files>
  <action>
**In `src/container-runner.ts`:**

1. Add `mcpServers` to the `ContainerInput` interface:
   ```typescript
   /** Pre-filtered MCP servers in SDK format (mode-compatible only). Merged with IPC MCP by agent-runner. */
   mcpServers?: Record<string, import('@anthropic-ai/claude-agent-sdk').McpStdioServerConfig | import('@anthropic-ai/claude-agent-sdk').McpSSEServerConfig | import('@anthropic-ai/claude-agent-sdk').McpHttpServerConfig>;
   ```
   Note: Use a plain serializable type here (not the SDK's McpSdkServerConfigWithInstance which contains a live McpServer object that can't be JSON serialized via stdin). The agent-runner will type-narrow when it receives the data.

   Actually, since container-runner.ts doesn't import the SDK, use a simple inline type:
   ```typescript
   mcpServers?: Record<string, Record<string, unknown>>;
   ```
   The agent-runner side will properly type this when it receives it. The important thing is that it's JSON-serializable.

**In `src/host-runner.ts`:**

1. Import `config` from `./config-loader.js` and `filterMcpServersByMode` -- WAIT. The filter module is in agent-runner, not in src/. The research recommends pre-filtering in the runner. Two approaches:
   - Option A: Duplicate simple filter logic in host-runner (bad -- DRY violation)
   - Option B: Pass raw servers to agent-runner, let it filter (good -- single filter point)

   Go with Option B: pass ALL configured mcpServers to agent-runner via ContainerInput. The agent-runner filters by mode using NANOCLAW_MODE env var which it already has. This is cleaner because:
   - Single point of filtering (agent-runner)
   - No need to import filter logic into host process
   - Container-runner can pass them too (future: container mode MCP servers)

2. In `runHostAgent()`, add `input.mcpServers` with the raw server configs from `config.mcpServers`. Since config.mcpServers contains NanoClaw format (with `modes` field etc.), pass it as-is. The agent-runner will filter and translate.

   After the existing security config block (around line 194), add:
   ```typescript
   // Pass configured MCP servers (agent-runner will filter by mode and translate to SDK format)
   if (config.mcpServers && Object.keys(config.mcpServers).length > 0) {
     input.mcpServers = config.mcpServers as Record<string, Record<string, unknown>>;
   }
   ```

3. Import `config` from `./config-loader.js` -- it's already imported (line 15 imports HostSecurityConfig, line 14 of index.ts imports config). Check: host-runner.ts already imports `HostSecurityConfig` from `./config-loader.js`. Add `config` to that import.

**In `src/index.ts`:**

No changes needed. The `agentInput` object at line 313-319 doesn't include mcpServers because host-runner.ts mutates the input object directly (it already mutates `input.security` at line 182). The mcpServers will be added the same way. The container-runner path doesn't need mcpServers yet (container mode MCP is future work).

IMPORTANT: Do NOT pass config.mcpServers from index.ts into agentInput. Keep the pattern consistent -- host-runner.ts adds mode-specific fields to the input it receives, just like it does for security.
  </action>
  <verify>
Run `npm run build` to verify the main app compiles with the updated ContainerInput interface and host-runner changes. Verify no type errors.
  </verify>
  <done>
- ContainerInput has optional mcpServers field
- host-runner.ts reads config.mcpServers and adds to input when servers exist
- Container-runner path unchanged (no mcpServers passed in container mode)
- Main app builds without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Agent-runner receives, filters, merges MCP servers with startup logging</name>
  <files>container/agent-runner/src/index.ts</files>
  <action>
In `container/agent-runner/src/index.ts`:

1. Import filterMcpServersByMode from the new module:
   ```typescript
   import { filterMcpServersByMode } from './mcp-filter.js';
   ```

2. Add `mcpServers` to the local `ContainerInput` interface (the agent-runner has its own copy, not imported from src/):
   ```typescript
   mcpServers?: Record<string, {
     command?: string;
     args?: string[];
     env?: Record<string, string>;
     type?: 'stdio' | 'sse' | 'http';
     url?: string;
     headers?: Record<string, string>;
     modes: string[];
   }>;
   ```

3. After parsing stdin input and before building queryOptions (between the `securityConfig` block around line 308-316 and the `settingSources` block around line 318), add MCP server filtering:
   ```typescript
   // Filter MCP servers by current execution mode
   let configMcpServers: Record<string, any> = {};
   if (input.mcpServers && Object.keys(input.mcpServers).length > 0) {
     const { active, filtered } = filterMcpServersByMode(input.mcpServers, NANOCLAW_MODE);
     configMcpServers = active;

     // Startup logging: show what's active and what's filtered
     const activeNames = Object.keys(active);
     if (activeNames.length > 0) {
       log(`MCP servers active (${NANOCLAW_MODE} mode): ${activeNames.join(', ')}`);
     }
     if (filtered.length > 0) {
       for (const f of filtered) {
         log(`MCP server filtered out: "${f.name}" (modes: [${f.modes.join(', ')}], current: ${NANOCLAW_MODE})`);
       }
     }
   }
   ```

4. Update the `mcpServers` in `queryOptions` to merge IPC MCP with config servers:
   Change:
   ```typescript
   mcpServers: {
     nanoclaw: ipcMcp
   },
   ```
   To:
   ```typescript
   mcpServers: {
     nanoclaw: ipcMcp,          // Always injected (IPC communication)
     ...configMcpServers,       // Config servers (pre-filtered by mode)
   },
   ```

   IMPORTANT: `nanoclaw` comes FIRST so it cannot be overridden by config servers. The mcp-filter.ts already excludes the reserved name "nanoclaw", but this ordering provides defense-in-depth.

5. Add a log line when NO MCP servers are configured (informational, not a warning):
   ```typescript
   if (!input.mcpServers || Object.keys(input.mcpServers).length === 0) {
     log('No additional MCP servers configured');
   }
   ```

6. After the query completes, if there were MCP server start failures, they'll show up in the agent's stderr output. The non-fatal behavior is provided by the SDK -- if an MCP server fails to start, the SDK logs the error and continues with remaining servers. No additional error handling needed in our code.

Do NOT modify the queryOptions spread pattern for security, sandbox, etc. -- only touch the mcpServers field.
  </action>
  <verify>
1. Run `npm run build:agent` to verify agent-runner compiles with all changes.
2. Run `npm run build` to verify main app still compiles.
3. Test end-to-end: Start the app with `npm run dev` and verify:
   - Startup log shows MCP server count from config-loader
   - Agent-runner log shows "MCP servers active" or "No additional MCP servers configured"
   - If a server is filtered out by mode, the log shows which server and why
  </verify>
  <done>
- Agent-runner imports and uses filterMcpServersByMode
- ContainerInput.mcpServers parsed from stdin
- Filtered servers merged with IPC MCP in query() options (IPC always takes precedence)
- Startup logs show active servers by name and filtered servers with reason
- No MCP servers configured produces informational log (not error)
- Both build targets compile successfully
- End-to-end: configured MCP servers load when modes match, are skipped when modes don't match
  </done>
</task>

</tasks>

<verification>
1. `npm run build && npm run build:agent` -- both compile without errors
2. With mcpServers in config: agent-runner logs show active/filtered server names
3. Without mcpServers in config: agent-runner logs "No additional MCP servers configured"
4. With a host-only server in container mode (if tested): server is filtered out with clear log message
5. IPC MCP server (nanoclaw) always present in query options regardless of config
6. A server named "nanoclaw" in config is warned about and excluded (does not override IPC)
7. App starts and responds to messages with MCP servers configured (non-fatal if server fails)
</verification>

<success_criteria>
- MCP servers from config flow through: config-loader -> host-runner -> stdin -> agent-runner -> query()
- Mode filtering works: only mode-compatible servers reach the SDK
- Startup logs clearly show active and filtered MCP servers
- IPC MCP server is always injected and cannot be overridden
- Both build targets compile and app runs end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/06-mcp-server-configuration-and-filtering/06-02-SUMMARY.md`
</output>
