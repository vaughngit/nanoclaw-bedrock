---
phase: 01-config-loader
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/config-loader.ts
autonomous: true

must_haves:
  truths:
    - "Config loader parses JSONC with inline comments, block comments, and trailing commas"
    - "Invalid config values produce a boxed ASCII error banner with field name, expected value, actual value, and fix hint"
    - "Unknown fields in config produce a boxed ASCII error banner naming the unrecognized keys"
    - "Absent config file returns default config with executionMode='container'"
    - "Valid config file returns a frozen, typed config object with the specified executionMode"
    - "Malformed JSON (syntax errors) produces a clear error banner with a hint about JSON syntax"
  artifacts:
    - path: "src/config-loader.ts"
      provides: "JSONC config loader with Zod validation, error formatting, and singleton export"
      exports: ["config", "NanoClawConfig"]
      min_lines: 80
  key_links:
    - from: "src/config-loader.ts"
      to: "strip-json-comments"
      via: "import stripJsonComments"
      pattern: "import stripJsonComments from 'strip-json-comments'"
    - from: "src/config-loader.ts"
      to: "zod"
      via: "z.strictObject schema"
      pattern: "z\\.strictObject"
    - from: "src/config-loader.ts"
      to: "src/logger.ts"
      via: "import { logger }"
      pattern: "import.*logger.*from.*logger"
---

<objective>
Create the core config loader module (`src/config-loader.ts`) that reads `nanoclaw.config.jsonc` from project root, strips JSONC comments, validates with Zod 4, and exports a frozen typed singleton. Also promote `strip-json-comments` from transitive to direct dependency.

Purpose: This is the config foundation that all subsequent phases build on. Without a working config loader, nothing else (execution mode switching, MCP server filtering, per-group overrides) can be implemented.
Output: `src/config-loader.ts` exporting `config` (singleton) and `NanoClawConfig` (type). `strip-json-comments` added to package.json as direct dependency.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-loader/01-RESEARCH.md
@.planning/phases/01-config-loader/01-CONTEXT.md

# Key source references
@src/config.ts
@src/logger.ts
@src/index.ts (lines 932-968 for boxed error banner pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add strip-json-comments as direct dependency</name>
  <files>package.json, package-lock.json</files>
  <action>
Run `npm install strip-json-comments` from the project root to promote it from transitive dependency (via pino-pretty) to direct dependency. This prevents it from disappearing if pino-pretty changes its dependency tree.

After install, verify:
- `strip-json-comments` appears in `package.json` under `dependencies`
- Version is 5.x (should be ^5.0.3 or similar)
- `npm ls strip-json-comments` shows it as a direct dep, not just transitive

Do NOT install any other packages. Do NOT modify any source files in this task.
  </action>
  <verify>
Run: `node -e "import('strip-json-comments').then(m => console.log(typeof m.default))"`
Expected: prints "function"

Run: `grep strip-json-comments package.json`
Expected: shows strip-json-comments in dependencies section
  </verify>
  <done>strip-json-comments is a direct dependency in package.json, importable as ESM</done>
</task>

<task type="auto">
  <name>Task 2: Create src/config-loader.ts with JSONC parsing, Zod validation, and error banners</name>
  <files>src/config-loader.ts</files>
  <action>
Create `src/config-loader.ts` implementing the full config loader. Follow the architecture from 01-RESEARCH.md precisely:

**Imports:**
- `fs` from `node:fs`
- `path` from `node:path`
- `stripJsonComments` from `strip-json-comments`
- `{ z }` from `zod`
- `{ logger }` from `./logger.js`

**Schema (Zod 4 strict object):**
```typescript
const NanoClawConfigSchema = z.strictObject({
  executionMode: z.enum(['container', 'host']).default('container'),
});
```

Use `z.strictObject()` (NOT `z.object()`) -- this rejects unknown keys, catching typos like "executonMode". Export the inferred type: `export type NanoClawConfig = z.output<typeof NanoClawConfigSchema>;`

**Main function `loadAndValidateConfig()`:**
1. Build config path: `path.join(process.cwd(), 'nanoclaw.config.jsonc')`
2. If file absent: log info "No nanoclaw.config.jsonc found, using defaults", parse `{}` through schema (fills defaults), freeze, return
3. If file exists: read with `fs.readFileSync(configPath, 'utf-8')`
4. Strip comments: `stripJsonComments(raw, { trailingCommas: true })`
5. JSON.parse the stripped content
6. Validate with `NanoClawConfigSchema.safeParse(data)`
7. On success: freeze result, log info summary "Config loaded: executionMode={value}", return
8. On any failure: print boxed ASCII error banner, call `process.exit(1)`

**Error handling -- three distinct failure modes:**

a) File read error: `printConfigError('Cannot read nanoclaw.config.jsonc', [error.message])`
b) JSON syntax error: `printConfigError('Invalid JSON in nanoclaw.config.jsonc', [syntaxError.message, 'Hint: Check for missing commas, unclosed braces, or invalid syntax'])`
c) Zod validation error: Format each issue from `result.error.issues` array:
   - `invalid_type`: `"{path}: expected {expected}, got invalid type"`
   - `invalid_value`: `"{path}: {message}"` + line with valid values from `issue.values`
   - `unrecognized_keys`: `"Unknown fields: {keys}"` + `"Hint: Check for typos in field names"`
   - default: `"{path}: {message}"`

**Boxed ASCII error banner function `printConfigError(title, details)`:**
Match the existing style from `src/index.ts` lines 943-965 (the `ensureContainerSystemRunning` pattern):
```
╔══════════════════════════════════════════════════════════════════╗
║  CONFIG ERROR: {title}                                          ║
╠══════════════════════════════════════════════════════════════════╣
║                                                                  ║
║  {detail line 1}                                                 ║
║  {detail line 2}                                                 ║
║                                                                  ║
╚══════════════════════════════════════════════════════════════════╝
```

Use a fixed width of 66 characters for the inner content area (matching the existing banner). Pad each line with spaces to fill the box width. Add a blank line before and after the detail lines for readability.

**Singleton export:**
```typescript
export const config: NanoClawConfig = loadAndValidateConfig();
```

The config is computed at module import time (synchronous). If invalid, `process.exit(1)` fires before the export completes.

**Important implementation details (from research):**
- Use `Object.freeze()` on the returned config for runtime immutability
- Wrap each step (readFile, stripComments, JSON.parse, zodValidate) in separate try/catch for precise error messages
- Do NOT throw errors -- use `process.exit(1)` after printing the banner (avoids ugly stack traces)
- Do NOT use `z.object()` -- it silently strips unknown keys. `z.strictObject()` rejects them.
- Put `.default('container')` on the `executionMode` field inside `z.strictObject()` -- Zod 4 `.default()` short-circuits on undefined so this is safe
  </action>
  <verify>
1. Verify the file compiles:
   Run: `npx tsc --noEmit src/config-loader.ts`
   Expected: No errors (or run full `npx tsc --noEmit`)

2. Verify absent config file returns defaults:
   Run: `node --import tsx/esm -e "import { config } from './src/config-loader.js'; console.log(JSON.stringify(config));"`
   Expected: `{"executionMode":"container"}` (assuming no nanoclaw.config.jsonc exists yet)

3. Verify JSONC parsing works with a test file:
   Create a temporary `nanoclaw.config.jsonc`:
   ```jsonc
   {
     // This is a comment
     "executionMode": "host", /* block comment */
   }
   ```
   Run the same import command.
   Expected: `{"executionMode":"host"}`
   Then delete the temporary file.

4. Verify unknown fields are rejected:
   Create a temporary `nanoclaw.config.jsonc`:
   ```json
   { "executonMode": "container" }
   ```
   Run the import command.
   Expected: Process exits with boxed error banner mentioning "Unknown fields: executonMode"
   Then delete the temporary file.
  </verify>
  <done>
src/config-loader.ts exists, exports typed `config` singleton and `NanoClawConfig` type. Parses JSONC (comments + trailing commas), validates with z.strictObject(), rejects unknown keys, shows boxed ASCII errors on failure, returns frozen defaults when config file is absent.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm ls strip-json-comments` shows it as direct dependency
2. `src/config-loader.ts` compiles without TypeScript errors
3. Importing `config-loader.ts` without a config file logs "No nanoclaw.config.jsonc found, using defaults" and exports `{ executionMode: 'container' }`
4. A config file with comments and trailing commas is parsed correctly
5. Unknown keys trigger a boxed error banner and `process.exit(1)`
6. Invalid enum values trigger a boxed error banner and `process.exit(1)`
</verification>

<success_criteria>
- `src/config-loader.ts` is a working module exporting `config` and `NanoClawConfig`
- JSONC parsing handles `//`, `/* */`, and trailing commas
- Zod strict object validation rejects unknown keys
- Error banners match existing codebase style (boxed ASCII)
- Default behavior (no config file) returns `{ executionMode: 'container' }`
- Config singleton is frozen (immutable)
- `strip-json-comments` is a direct dependency in package.json
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-loader/01-01-SUMMARY.md`
</output>
