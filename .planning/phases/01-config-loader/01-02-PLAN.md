---
phase: 01-config-loader
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Config loads before any other startup logic (before ensureContainerSystemRunning, before initDatabase)"
    - "App starts and runs in container mode with identical behavior when nanoclaw.config.jsonc is absent"
    - "App starts successfully with a valid nanoclaw.config.jsonc present"
    - "App fails with a clear error when nanoclaw.config.jsonc has invalid content"
    - "Config loaded info-level log appears in startup output before database and container logs"
  artifacts:
    - path: "src/index.ts"
      provides: "Config loader import at top of file"
      contains: "import.*config-loader"
  key_links:
    - from: "src/index.ts"
      to: "src/config-loader.ts"
      via: "top-level import (module-level singleton loads config at import time)"
      pattern: "import.*from.*config-loader"
---

<objective>
Wire the config loader into the app's startup sequence so it loads as the very first thing -- before database, before WhatsApp/Slack, before container system check. Verify the app starts identically to before when no config file exists (zero behavioral change for existing users).

Purpose: The config loader only delivers value when it's actually integrated into the app. This plan wires it in and proves backward compatibility -- the single most important constraint for Phase 1.
Output: `src/index.ts` imports `config-loader.ts` at the top, config loads at module import time before `main()` runs.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-loader/01-RESEARCH.md
@.planning/phases/01-config-loader/01-CONTEXT.md
@.planning/phases/01-config-loader/01-01-SUMMARY.md

# Key source references
@src/index.ts (lines 1-30 for imports, lines 990-1023 for main())
@src/config-loader.ts (created in Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config-loader import to src/index.ts</name>
  <files>src/index.ts</files>
  <action>
Add a single import line to `src/index.ts` that imports the config singleton from the new config-loader module. This import MUST be placed at the very top of the local imports section (after third-party imports like baileys, cron-parser, etc., but BEFORE the existing `./config.js` import).

The import line:
```typescript
import { config as nanoclawConfig } from './config-loader.js';
```

Use the alias `nanoclawConfig` to avoid naming conflicts with the existing `config.ts` exports. The existing `src/config.ts` exports individual constants (ASSISTANT_NAME, DATA_DIR, etc.) which are imported by name -- there's no conflict on the import names, but using `nanoclawConfig` makes the distinction clear and self-documenting.

**Why this is placed before `./config.js`:** ES module imports are evaluated top-down in source order. By placing the config-loader import first, the JSONC config file is loaded and validated before any other module-level code runs. If the config is invalid, `process.exit(1)` fires immediately -- the app never gets to database init, WhatsApp connection, or container checks.

**IMPORTANT: Do NOT modify anything else in index.ts.** The config value is available via `nanoclawConfig` but Phase 1 does NOT wire it to any runtime behavior. The `executionMode` value is loaded and logged but not acted upon. Later phases (3, 4) will use it to switch between container and host runners.

The config singleton auto-loads at import time (module-level execution in config-loader.ts). There is no function to call in `main()`. The import statement IS the integration.
  </action>
  <verify>
1. Verify the import was added correctly:
   Run: `head -40 src/index.ts`
   Expected: See `import { config as nanoclawConfig } from './config-loader.js';` before the `./config.js` import

2. Verify TypeScript compiles:
   Run: `npx tsc --noEmit`
   Expected: No errors
  </verify>
  <done>src/index.ts imports config-loader.ts at the top of local imports, config loads at module import time before main() runs</done>
</task>

<task type="auto">
  <name>Task 2: Verify app startup behavior with and without config file</name>
  <files>src/index.ts</files>
  <action>
Run the app briefly in dev mode to verify startup behavior in two scenarios. This is a verification-only task -- no code changes.

**Scenario A: No config file (backward compatibility)**
1. Ensure no `nanoclaw.config.jsonc` exists at project root
2. Run `npm run dev` and observe the first few seconds of startup output
3. Verify you see: "No nanoclaw.config.jsonc found, using defaults" in the logs
4. Verify the app continues past this to database init, container system check, WhatsApp connection -- identical to before
5. Kill the process (Ctrl+C or SIGINT)

**Scenario B: Valid config file**
1. Create a temporary `nanoclaw.config.jsonc` at project root:
   ```jsonc
   {
     // NanoClaw configuration
     "executionMode": "container",  // default mode
   }
   ```
2. Run `npm run dev` and observe startup
3. Verify you see: "Config loaded: executionMode=container" in the logs
4. Verify the app continues normally to database init, container check, WhatsApp connection
5. Kill the process
6. Delete the temporary config file

**Scenario C: Invalid config file (error handling)**
1. Create a temporary `nanoclaw.config.jsonc` at project root:
   ```json
   { "executionMode": "docker" }
   ```
2. Run `npm run dev`
3. Verify: Process exits immediately with a boxed ASCII error banner containing the word "executionMode" and indicating "docker" is not a valid value
4. Delete the temporary config file

If any scenario fails, diagnose the issue in `src/config-loader.ts` and fix it. The most likely issues:
- Import path wrong (must be `./config-loader.js` with `.js` extension for ESM)
- Logger not initialized yet when config-loader imports it (check logger.ts has no async initialization)
- Zod error format differs from expected (check `issue.code` values match the research)

Do NOT change the app's runtime behavior. The config is loaded and logged but not used to change any decisions yet.
  </action>
  <verify>
Scenario A check: `ls nanoclaw.config.jsonc 2>/dev/null || echo "no config file"` returns "no config file" AND app starts normally with default log message.

Scenario B check: Config file with `"executionMode": "container"` produces "Config loaded" log AND app starts normally.

Scenario C check: Config file with `"executionMode": "docker"` produces boxed error banner AND process exits with code 1.
  </verify>
  <done>
App starts identically to before when no config file is present (backward compatibility verified). Valid config file loads successfully with summary log. Invalid config file produces clear boxed error and exits. Config loads before database, container system, and WhatsApp/Slack.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `src/index.ts` has `import { config as nanoclawConfig } from './config-loader.js'` before other local imports
2. `npx tsc --noEmit` passes with zero errors
3. App startup without config file: logs "No nanoclaw.config.jsonc found, using defaults", continues normally
4. App startup with valid config: logs "Config loaded: executionMode=container", continues normally
5. App startup with invalid config: prints boxed error banner, exits with code 1
6. Config log line appears BEFORE database and container system log lines in startup output
</verification>

<success_criteria>
- Config-loader is imported in index.ts and loads before all other startup logic
- Zero behavioral change when nanoclaw.config.jsonc is absent (backward compatibility)
- Valid config files are accepted and logged
- Invalid config files produce clear errors and stop startup
- No existing functionality is broken
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-loader/01-02-SUMMARY.md`
</output>
