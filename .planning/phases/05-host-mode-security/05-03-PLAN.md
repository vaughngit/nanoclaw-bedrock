---
phase: 05-host-mode-security
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/host-runner.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Host-runner passes security config to agent-runner for non-main groups"
    - "Host-runner does NOT pass security config for main group (main is unrestricted)"
    - "Sandbox violation errors in host agent output trigger WhatsApp alert to main group"
    - "Sandbox violations are logged to the group's log file for audit trail"
    - "Main group JID is resolved from registeredGroups for alert delivery"
  artifacts:
    - path: "src/host-runner.ts"
      provides: "Security config resolution, violation alert detection, alert IPC writing"
      contains: "SANDBOX ALERT"
    - path: "src/index.ts"
      provides: "Main group JID passed to host-runner, config.hostSecurity access"
      contains: "mainGroupJid"
  key_links:
    - from: "src/index.ts"
      to: "src/host-runner.ts"
      via: "runHostAgent receives hostSecurity config and mainGroupJid"
      pattern: "config\\.hostSecurity"
    - from: "src/host-runner.ts"
      to: "container/agent-runner/src/index.ts"
      via: "ContainerInput.security passed via stdin JSON"
      pattern: "security:"
    - from: "src/host-runner.ts"
      to: "IPC messages directory (main group)"
      via: "Writes sandbox alert JSON file to main group's IPC messages dir"
      pattern: "sandbox-alert"
---

<objective>
Wire host-runner to pass security config to agent-runner, detect sandbox violations in agent output, and send real-time WhatsApp alerts to the main group. Wire index.ts to provide the necessary config and main group JID to host-runner.

Purpose: Complete the security pipeline from config -> host-runner -> agent-runner, and implement the user's requirement for visibility into what's being blocked via real-time WhatsApp alerts.
Output: Host-runner passes security config, detects violations, and alerts main group. Index.ts provides config and JID context.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-host-mode-security/05-RESEARCH.md
@.planning/phases/05-host-mode-security/05-01-PLAN.md
@src/host-runner.ts
@src/index.ts
@src/config-loader.ts
@src/container-runner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pass security config through host-runner to agent-runner</name>
  <files>src/host-runner.ts, src/index.ts</files>
  <action>
**host-runner.ts changes:**

1. Import `HostSecurityConfig` from config-loader:
```typescript
import { HostSecurityConfig } from './config-loader.js';
```

2. Add a `SecurityOptions` parameter to `runHostAgent` for the resolved security config and main group context:
```typescript
export interface HostRunnerSecurityContext {
  hostSecurity?: HostSecurityConfig;
  mainGroupJid?: string;    // For sandbox violation alerts
  mainGroupFolder: string;  // Always 'main'
}
```

3. Update `runHostAgent` signature to accept the security context:
```typescript
export async function runHostAgent(
  group: RegisteredGroup,
  input: ContainerInput,
  onProcess: (proc: ChildProcess, containerName: null) => void,
  securityCtx?: HostRunnerSecurityContext,
): Promise<ContainerOutput> {
```

4. Before sending input via stdin, resolve and attach security config for non-main groups:
```typescript
// Resolve security config for non-main groups
const isMain = input.isMain;
if (!isMain && securityCtx?.hostSecurity) {
  input.security = {
    sandbox: securityCtx.hostSecurity.sandbox,
    tools: securityCtx.hostSecurity.tools,
  };
  logger.debug(
    {
      group: group.name,
      sandbox: input.security.sandbox,
      tools: input.security.tools ?? 'all (default)',
    },
    'Host agent security config applied',
  );
}
```

Place this BEFORE the `proc.stdin.write(JSON.stringify(input))` line so the security field is included in the stdin JSON.

5. Log security mode in the info log:
```typescript
logger.info(
  {
    group: group.name,
    isMain: input.isMain,
    sandboxed: !isMain && input.security?.sandbox !== false,
    permissionMode: isMain ? 'bypassPermissions' : 'default',
  },
  'Spawning host agent',
);
```

**index.ts changes:**

6. Import config (already imported as `config` from `./config-loader.js`). Find the main group JID by looking up registeredGroups for the group with folder === MAIN_GROUP_FOLDER:

In the `runAgent` function, where `runHostAgent` is called (around line 321-325), update the call to pass the security context:

```typescript
const output = config.executionMode === 'host'
  ? await runHostAgent(
      group,
      agentInput,
      (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
      {
        hostSecurity: config.hostSecurity,
        mainGroupJid: Object.entries(registeredGroups).find(
          ([, g]) => g.folder === MAIN_GROUP_FOLDER
        )?.[0],
        mainGroupFolder: MAIN_GROUP_FOLDER,
      },
    )
  : await runContainerAgent(
      group,
      agentInput,
      (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
    );
```

7. Do the same in task-scheduler.ts if it also calls runHostAgent. Search for all call sites:
```bash
grep -rn "runHostAgent" src/
```
If task-scheduler.ts calls runHostAgent, apply the same security context pattern. If not (if it calls runAgent from index.ts instead), no change needed.
  </action>
  <verify>
Run `npm run build` to ensure TypeScript compiles. Check that index.ts passes hostSecurity and mainGroupJid to runHostAgent. Check that host-runner attaches security config to input for non-main groups.
  </verify>
  <done>
Host-runner receives security config from index.ts. Non-main groups get security field attached to ContainerInput before sending to agent-runner. Main group gets no security field (unrestricted). Main group JID is resolved for alert delivery.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sandbox violation detection and WhatsApp alerting</name>
  <files>src/host-runner.ts</files>
  <action>
Add sandbox violation detection to the host-runner's `proc.on('close')` handler. When a non-main agent completes with an error that appears sandbox-related, write an IPC message file to the MAIN group's IPC messages directory so the main group gets an immediate WhatsApp alert.

**1. Add the violation detection function:**

```typescript
/**
 * Detect sandbox-related errors in agent output.
 * The SDK sandbox uses macOS Seatbelt which produces various error messages.
 * Match broadly to catch different Seatbelt error formats.
 */
function isSandboxViolation(errorText: string): boolean {
  const patterns = [
    'sandbox',
    'seatbelt',
    'operation not permitted',
    'not allowed by sandbox',
    'deny(default)',
  ];
  const lower = errorText.toLowerCase();
  return patterns.some(p => lower.includes(p));
}
```

**2. Add the alert function:**

```typescript
/**
 * Send a sandbox violation alert to the main group via IPC.
 * Writes a message file that the IPC poller picks up and delivers via WhatsApp.
 * Also logs to the violating group's log directory for audit.
 */
function sendSandboxAlert(
  groupName: string,
  groupFolder: string,
  errorText: string,
  securityCtx: HostRunnerSecurityContext,
): void {
  // Log to group's log directory for audit trail
  const logsDir = path.join(GROUPS_DIR, groupFolder, 'logs');
  fs.mkdirSync(logsDir, { recursive: true });
  const auditFile = path.join(
    logsDir,
    `sandbox-violation-${new Date().toISOString().replace(/[:.]/g, '-')}.log`
  );
  fs.writeFileSync(auditFile, [
    `=== Sandbox Violation ===`,
    `Timestamp: ${new Date().toISOString()}`,
    `Group: ${groupName} (${groupFolder})`,
    `Error: ${errorText}`,
  ].join('\n'));

  // Send WhatsApp alert to main group if we have the JID
  if (securityCtx.mainGroupJid) {
    const mainIpcMessages = path.join(
      DATA_DIR, 'ipc', securityCtx.mainGroupFolder, 'messages'
    );
    fs.mkdirSync(mainIpcMessages, { recursive: true });

    const alertFilename = `${Date.now()}-sandbox-alert.json`;
    const alertData = {
      type: 'message',
      chatJid: securityCtx.mainGroupJid,
      text: `[SANDBOX ALERT] Agent in "${groupName}" hit a restriction:\n${errorText.slice(0, 300)}`,
      groupFolder: securityCtx.mainGroupFolder,
      timestamp: new Date().toISOString(),
    };

    // Atomic write
    const tempPath = path.join(mainIpcMessages, `${alertFilename}.tmp`);
    fs.writeFileSync(tempPath, JSON.stringify(alertData, null, 2));
    fs.renameSync(tempPath, path.join(mainIpcMessages, alertFilename));

    logger.warn(
      { group: groupName, alertFile: alertFilename },
      'Sandbox violation alert sent to main group',
    );
  } else {
    logger.warn(
      { group: groupName },
      'Sandbox violation detected but no main group JID available for alert',
    );
  }
}
```

**3. Integrate violation detection into the close handler.**

In the `proc.on('close')` callback, AFTER the error output is resolved but BEFORE the function returns, add violation detection. Find the block that handles `code !== 0` (around line 241-259 in current host-runner.ts):

After the existing error logging and before `resolve(...)`, add:

```typescript
// Detect sandbox violations and alert main group
if (!input.isMain && securityCtx) {
  const fullError = `${stderr}\n${stdout}`;
  if (isSandboxViolation(fullError)) {
    sendSandboxAlert(group.name, group.folder, stderr.slice(-500), securityCtx);
  }
}
```

Also check the successful completion path -- a sandbox violation might not cause a non-zero exit code but might appear in stderr. After the successful output parsing block (around line 290), add:

```typescript
// Check for sandbox violations even on "success" (may appear in stderr)
if (!input.isMain && securityCtx && stderr) {
  if (isSandboxViolation(stderr)) {
    sendSandboxAlert(group.name, group.folder, stderr.slice(-500), securityCtx);
  }
}
```

**4. Include sandbox alert info in the existing log file.**

In the log lines written on error, add a line indicating whether a sandbox alert was sent:

```typescript
if (!input.isMain && securityCtx && isSandboxViolation(`${stderr}\n${stdout}`)) {
  logLines.push(``, `=== Sandbox Violation Detected ===`, `Alert sent to main group: ${!!securityCtx.mainGroupJid}`);
}
```
  </action>
  <verify>
Run `npm run build` to ensure compilation succeeds. Code review: verify that sandbox violations are detected in both error and success paths, that alerts write to the main group's IPC directory, and that audit logs are written to the violating group's log directory.
  </verify>
  <done>
Sandbox violations detected via pattern matching on stderr/stdout. Alerts sent to main group via IPC message file (picked up by existing IPC poller and delivered via WhatsApp). Audit trail written to violating group's log directory. Both error and success paths checked for violations.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no type errors
2. Code review: index.ts passes config.hostSecurity and mainGroupJid to runHostAgent
3. Code review: host-runner attaches security config to ContainerInput for non-main groups only
4. Code review: host-runner detects sandbox violations in both error and success paths
5. Code review: violation alerts are written as IPC message files to main group's messages directory
6. Code review: audit logs are written to the violating group's logs directory
7. Code review: main group never gets security restrictions (no security field in input)
</verification>

<success_criteria>
- Security config flows from nanoclaw.config.jsonc -> config-loader -> index.ts -> host-runner -> agent-runner via stdin
- Non-main group agents receive sandbox and tool restrictions
- Main group agents remain unrestricted
- Sandbox violations produce immediate WhatsApp alerts to main group
- Violations logged for audit trail
- End-to-end security pipeline is wired and compiles
</success_criteria>

<output>
After completion, create `.planning/phases/05-host-mode-security/05-03-SUMMARY.md`
</output>
