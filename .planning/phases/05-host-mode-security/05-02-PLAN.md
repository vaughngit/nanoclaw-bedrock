---
phase: 05-host-mode-security
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - container/agent-runner/src/index.ts
  - container/agent-runner/src/ipc-mcp.ts
autonomous: true

must_haves:
  truths:
    - "Non-main groups use permissionMode 'default' instead of 'bypassPermissions'"
    - "Non-main groups run with SDK sandbox enabled when security.sandbox is true"
    - "Non-main groups have tool availability restricted to security.tools when configured"
    - "NanoClaw MCP tools (mcp__nanoclaw__*) are always available regardless of tool allowlist"
    - "IPC write operations validate the target directory is within the agent's own IPC namespace"
    - "Non-main groups use settingSources: ['project'] only (no user settings leakage)"
    - "Non-main agents explain permission restrictions to the group chat"
  artifacts:
    - path: "container/agent-runner/src/index.ts"
      provides: "Security-differentiated query options, PreToolUse hook"
      contains: "permissionMode"
    - path: "container/agent-runner/src/ipc-mcp.ts"
      provides: "IPC write path validation (defense in depth)"
      contains: "IPC write blocked"
  key_links:
    - from: "container/agent-runner/src/index.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "SDK query() options: sandbox, tools, permissionMode"
      pattern: "sandbox.*enabled"
    - from: "container/agent-runner/src/ipc-mcp.ts"
      to: "container/agent-runner/src/index.ts"
      via: "IPC directory passed from main to createIpcMcp"
      pattern: "normalizedDir.*startsWith"
---

<objective>
Make the agent-runner security-aware: differentiate query() options between main and non-main groups based on the security config received via stdin. Add IPC write path validation and a PreToolUse hook for permission denial messaging.

Purpose: This is the core security enforcement -- non-main agents get sandbox, default permissions, and tool restrictions. Main group remains unrestricted. IPC writes are validated to prevent cross-group access.
Output: Security-differentiated agent-runner that enforces sandbox, permission mode, tool allowlist, and IPC isolation.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-host-mode-security/05-RESEARCH.md
@.planning/phases/05-host-mode-security/05-01-PLAN.md
@container/agent-runner/src/index.ts
@container/agent-runner/src/ipc-mcp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Security-differentiated query options in agent-runner</name>
  <files>container/agent-runner/src/index.ts</files>
  <action>
**1. Extend the local ContainerInput interface** to include the security field (matching the type added in Plan 01):

```typescript
interface ContainerInput {
  prompt: string;
  sessionId?: string;
  groupFolder: string;
  chatJid: string;
  isMain: boolean;
  isScheduledTask?: boolean;
  security?: {
    sandbox: boolean;
    tools?: string[];
  };
}
```

**2. Change `allowedTools` to `tools` for non-main groups.**

CRITICAL: The current code uses `allowedTools` which only controls auto-approval, NOT tool availability. For non-main groups, we must use `tools` (positive allowlist) to actually restrict which tools are available. For main groups, keep the current behavior (all tools available).

Research finding: `allowedTools` = "auto-approve these tools without prompts." `tools` = "these are the ONLY tools available." We need `tools` for restriction.

**3. Differentiate query options based on isMain and security config.**

Replace the current hardcoded queryOptions block with security-aware logic:

```typescript
const securityConfig = input.security;
const isMain = input.isMain;

// Setting sources: non-main groups use 'project' only to prevent shared ~/.claude permission leaks
// (see Research Pitfall 4: settings written by one group's session would leak to others)
const settingSources: ('project' | 'user')[] =
  isMain ? ['project', 'user'] : ['project'];

// Build tool list for non-main groups
// NanoClaw MCP tools always included (needed for IPC communication)
const nonMainTools = securityConfig?.tools
  ? [...securityConfig.tools, 'mcp__nanoclaw__*']
  : [
      'Bash', 'Read', 'Write', 'Edit', 'Glob', 'Grep',
      'WebSearch', 'WebFetch',
      'mcp__nanoclaw__*'
    ];

const queryOptions = {
  cwd: GROUP_DIR,
  systemPrompt: globalClaudeMd
    ? { type: 'preset' as const, preset: 'claude_code' as const, append: globalClaudeMd }
    : undefined,

  // TOOLS: main gets all tools (no `tools` or `allowedTools` needed -- bypassPermissions
  // already auto-approves everything, and omitting `tools` means full SDK default tool set).
  // Non-main gets `tools` (positive allowlist) restricting which tools are AVAILABLE.
  ...(!isMain
    ? { tools: nonMainTools }
    : {}),

  // PERMISSION MODE: main bypasses all, non-main uses default (prompts for destructive ops)
  permissionMode: isMain ? 'bypassPermissions' as const : 'default' as const,
  allowDangerouslySkipPermissions: isMain,

  // SANDBOX: main exempt, non-main sandboxed when configured
  // sandbox only affects Bash tool (wraps in macOS Seatbelt)
  // allowUnsandboxedCommands: false prevents model from escaping with dangerouslyDisableSandbox
  ...(!isMain && NANOCLAW_MODE === 'host' && securityConfig?.sandbox !== false
    ? {
        sandbox: {
          enabled: true,
          autoAllowBashIfSandboxed: true,
          allowUnsandboxedCommands: false,
        },
      }
    : {}),

  settingSources,
  mcpServers: {
    nanoclaw: ipcMcp
  },
  hooks: {
    PreCompact: [{ hooks: [createPreCompactHook()] }],
    // Non-main groups get a PreToolUse hook that instructs the model
    // to explain permission denials to the group chat
    ...(!isMain ? {
      PreToolUse: [{ hooks: [createPermissionDenialHook()] }],
    } : {}),
  },
  outputFormat: {
    type: 'json_schema' as const,
    schema: AGENT_RESPONSE_SCHEMA,
  }
};
```

**4. Create the permission denial hook function.**

Add this function before `main()`:

```typescript
function createPermissionDenialHook(): HookCallback {
  return async (_input, _toolUseId, _context) => {
    return {
      hookSpecificOutput: {
        hookEventName: 'PreToolUse' as const,
        additionalContext: 'If any tool use is denied due to permissions or sandbox restrictions, use the mcp__nanoclaw__send_message tool to explain to the group what you cannot do and why. Suggest they contact the admin group for assistance. Do not silently fail.',
      }
    };
  };
}
```

Import `HookCallback` from the SDK if not already imported (it is already imported on line 8).

**5. Log security configuration on startup.**

After parsing input, add a log line showing the security config being applied:

```typescript
if (!input.isMain && input.security) {
  log(`Security config: sandbox=${input.security.sandbox}, tools=${input.security.tools ? input.security.tools.join(',') : 'all'}`);
}
if (!input.isMain) {
  log(`Permission mode: default (non-main group)`);
}
```
  </action>
  <verify>
Run `npm run build:agent` to compile the agent-runner. Check there are no TypeScript errors. The compiled output at `container/agent-runner/dist/index.js` should exist.
  </verify>
  <done>
Agent-runner uses `tools` (not `allowedTools`) for non-main groups. Non-main groups get `permissionMode: 'default'`, sandbox enabled by default, `settingSources: ['project']` (no redundant mode check), and a PreToolUse hook for permission denial messaging. Main group keeps `bypassPermissions`, no sandbox, no explicit tool list (SDK defaults to full set). NanoClaw MCP tools always included for non-main.
  </done>
</task>

<task type="auto">
  <name>Task 2: IPC write path validation in ipc-mcp.ts</name>
  <files>container/agent-runner/src/ipc-mcp.ts</files>
  <action>
Add defense-in-depth IPC write path validation to the `writeIpcFile` function. This prevents an agent from writing to another group's IPC directory even if the sandbox doesn't cover it (since sandbox only affects Bash tool, not in-process MCP operations).

Modify `writeIpcFile` to accept the base IPC directory and validate the target dir:

```typescript
function writeIpcFile(dir: string, baseIpcDir: string, data: object): string {
  // Defense in depth: verify target dir is within our IPC namespace
  const normalizedDir = path.resolve(dir);
  const normalizedBase = path.resolve(baseIpcDir);
  if (!normalizedDir.startsWith(normalizedBase + path.sep) &&
      normalizedDir !== normalizedBase) {
    throw new Error(`IPC write blocked: ${dir} is outside authorized IPC directory ${baseIpcDir}`);
  }

  fs.mkdirSync(dir, { recursive: true });

  const filename = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}.json`;
  const filepath = path.join(dir, filename);

  // Atomic write: temp file then rename
  const tempPath = `${filepath}.tmp`;
  fs.writeFileSync(tempPath, JSON.stringify(data, null, 2));
  fs.renameSync(tempPath, filepath);

  return filename;
}
```

Update ALL callers of `writeIpcFile` within `createIpcMcp` to pass `ipcDir` as the second argument:

- `writeIpcFile(MESSAGES_DIR, ipcDir, data)` -- for send_message, send_image
- `writeIpcFile(TASKS_DIR, ipcDir, data)` -- for schedule_task, pause_task, resume_task, cancel_task, register_group

This is a simple find-and-replace: every `writeIpcFile(MESSAGES_DIR, data)` becomes `writeIpcFile(MESSAGES_DIR, ipcDir, data)` and every `writeIpcFile(TASKS_DIR, data)` becomes `writeIpcFile(TASKS_DIR, ipcDir, data)`.

The validation ensures that even if an agent somehow manipulates the IPC directory path arguments, the write is blocked if it's outside the authorized namespace.
  </action>
  <verify>
Run `npm run build:agent` to compile. Verify no type errors. The path validation logic should prevent writes outside the IPC dir -- this is a runtime guard, validated by code review.
  </verify>
  <done>
writeIpcFile validates that every IPC write target is within the agent's authorized IPC directory. All 7 callers pass the base IPC dir for validation. Defense-in-depth layer works alongside OS-level sandbox enforcement.
  </done>
</task>

</tasks>

<verification>
1. `npm run build:agent` succeeds with no TypeScript errors
2. Code review: non-main groups have `permissionMode: 'default'`, `tools: [...]`, and `sandbox: { enabled: true }` when security.sandbox is true
3. Code review: main group has `permissionMode: 'bypassPermissions'`, no explicit tool list (SDK default = all), and no sandbox
4. Code review: `mcp__nanoclaw__*` is present in both main and non-main tool lists
5. Code review: writeIpcFile validates directory path before every write
6. Code review: settingSources is `['project']` for non-main in host mode
7. Code review: PreToolUse hook present for non-main groups only
</verification>

<success_criteria>
- Agent-runner differentiates security between main and non-main groups
- Non-main: sandbox enabled, default permissions, restricted tools, project-only settings
- Main: no sandbox, bypassPermissions, all tools (SDK default, no explicit list), project+user settings
- IPC writes validated against authorized directory
- Permission denial hook instructs model to explain restrictions to users
</success_criteria>

<output>
After completion, create `.planning/phases/05-host-mode-security/05-02-SUMMARY.md`
</output>
