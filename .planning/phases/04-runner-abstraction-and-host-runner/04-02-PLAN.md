---
phase: 04-runner-abstraction-and-host-runner
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/index.ts
  - src/task-scheduler.ts
autonomous: false

must_haves:
  truths:
    - "When executionMode is 'host', the app spawns node agent-runner directly instead of launching a container"
    - "When executionMode is 'container', behavior is identical to pre-Phase-4 (no regressions)"
    - "ensureContainerSystemRunning() only runs in container mode"
    - "Task scheduler uses host runner in host mode"
    - "A message sent to a registered group in host mode produces a response from the agent"
  artifacts:
    - path: "src/index.ts"
      provides: "Mode-routed agent invocation and conditional container startup"
      contains: "runHostAgent"
    - path: "src/task-scheduler.ts"
      provides: "Mode-routed task execution"
      contains: "runHostAgent"
  key_links:
    - from: "src/index.ts"
      to: "src/host-runner.ts"
      via: "import and conditional call based on config.executionMode"
      pattern: "config\\.executionMode.*host.*runHostAgent"
    - from: "src/index.ts"
      to: "src/config-loader.ts"
      via: "named import of config singleton"
      pattern: "import.*config.*config-loader"
    - from: "src/task-scheduler.ts"
      to: "src/host-runner.ts"
      via: "injected runner function or conditional import"
      pattern: "runHostAgent|runAgent"
    - from: "src/index.ts"
      to: "ensureContainerSystemRunning"
      via: "conditional call gated on executionMode"
      pattern: "config\\.executionMode.*container.*ensureContainerSystemRunning"
---

<objective>
Wire host-runner into the application routing so the app uses the correct runner based on config.executionMode, and verify end-to-end.

Purpose: This plan connects the host-runner created in Plan 01 to the actual message flow and task scheduler, making host mode functional. It also gates container-specific startup logic on container mode.

Output: Working host mode -- messages route through host-runner when executionMode is "host". End-to-end verified.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-runner-abstraction-and-host-runner/04-01-PLAN.md

@src/index.ts
@src/task-scheduler.ts
@src/host-runner.ts
@src/container-runner.ts
@src/config-loader.ts
@src/config.ts
@src/group-queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire mode routing in index.ts and task-scheduler.ts</name>
  <files>src/index.ts, src/task-scheduler.ts</files>
  <action>
Three wiring changes to make host mode functional:

**1. Add config import and host-runner import to index.ts:**

Change the existing side-effect import:
```ts
import './config-loader.js'; // Side-effect: loads + validates nanoclaw.config.jsonc at startup
```
Keep it AND add a named import:
```ts
import './config-loader.js'; // Side-effect: loads + validates nanoclaw.config.jsonc at startup
import { config } from './config-loader.js';
```

Add host-runner import:
```ts
import { runHostAgent } from './host-runner.js';
```

**2. Gate ensureContainerSystemRunning() on container mode:**

In the `main()` function, change:
```ts
ensureContainerSystemRunning();
```
to:
```ts
if (config.executionMode === 'container') {
  ensureContainerSystemRunning();
} else {
  logger.info({ executionMode: config.executionMode }, 'Skipping container system check (non-container mode)');
}
```

**3. Route runAgent() based on executionMode:**

In the `runAgent()` function in index.ts, change the try block from:
```ts
const output = await runContainerAgent(
  group,
  {
    prompt,
    sessionId,
    groupFolder: group.folder,
    chatJid,
    isMain,
  },
  (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
);
```
to:
```ts
const agentInput = {
  prompt,
  sessionId,
  groupFolder: group.folder,
  chatJid,
  isMain,
};

const output = config.executionMode === 'host'
  ? await runHostAgent(
      group,
      agentInput,
      (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
    )
  : await runContainerAgent(
      group,
      agentInput,
      (proc, containerName) => queue.registerProcess(chatJid, proc, containerName),
    );
```

**4. Route task-scheduler.ts based on executionMode:**

In `src/task-scheduler.ts`, add imports:
```ts
import { config } from './config-loader.js';
import { runHostAgent } from './host-runner.js';
```

In the `runTask()` function, change:
```ts
const output = await runContainerAgent(
  group,
  {
    prompt: task.prompt,
    sessionId,
    groupFolder: task.group_folder,
    chatJid: task.chat_jid,
    isMain,
  },
  (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
);
```
to:
```ts
const agentInput = {
  prompt: task.prompt,
  sessionId,
  groupFolder: task.group_folder,
  chatJid: task.chat_jid,
  isMain,
};

const output = config.executionMode === 'host'
  ? await runHostAgent(
      group,
      agentInput,
      (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
    )
  : await runContainerAgent(
      group,
      agentInput,
      (proc, containerName) => deps.onProcess(task.chat_jid, proc, containerName),
    );
```

**5. Log the execution mode at startup:**

In the `main()` function, after `loadState()`, add:
```ts
logger.info({ executionMode: config.executionMode }, 'Execution mode');
```

This makes it immediately clear in logs which mode the app is running in.
  </action>
  <verify>
Run `npx tsc --noEmit` -- must pass with no type errors.
Verify that `src/index.ts` imports both `config` from config-loader and `runHostAgent` from host-runner.
Verify that `ensureContainerSystemRunning()` is gated behind `config.executionMode === 'container'`.
Verify routing logic completeness in both callsites:
  - `grep -A3 'executionMode.*host' src/index.ts` must show `runHostAgent` called in `runAgent()` function.
  - `grep -A3 'executionMode.*host' src/task-scheduler.ts` must show `runHostAgent` called in `runTask()` function.
  - `grep -c 'runContainerAgent' src/index.ts` must show `runContainerAgent` still present (container branch).
  - `grep -c 'runContainerAgent' src/task-scheduler.ts` must show `runContainerAgent` still present (container branch).
This confirms both `runAgent()` and `runTask()` have conditional logic routing to `runHostAgent` vs `runContainerAgent` based on `config.executionMode`.
  </verify>
  <done>
index.ts and task-scheduler.ts route to the correct runner based on executionMode. Container system check is conditional. Startup logs the execution mode. TypeScript compiles cleanly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete host-mode agent execution. When `executionMode` is set to `"host"` in `nanoclaw.config.jsonc`, the app spawns agents as native macOS Node.js subprocesses instead of launching containers. The same IPC protocol, sentinel output parsing, and queue integration are used.
  </what-built>
  <how-to-verify>
1. Ensure agent-runner is compiled: `npm run build:agent`
2. Set `"executionMode": "host"` in `nanoclaw.config.jsonc`
3. Start the app: `npm run dev`
4. Verify startup log shows: `Execution mode: host` and does NOT attempt container system start
5. Send a message to the "nano" group via WhatsApp (mention @Nano)
6. Verify a response comes back (proves end-to-end: message -> host-runner -> agent-runner subprocess -> sentinel parse -> response -> WhatsApp)
7. Check `groups/main/logs/` for a `host-*.log` file confirming the subprocess ran
8. Stop the app, set `"executionMode": "container"` back, restart, and verify container mode still works (regression check)
  </how-to-verify>
  <resume-signal>Type "approved" if host mode works end-to-end, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Container mode: `ensureContainerSystemRunning()` runs, agents spawn in containers
3. Host mode: container check is skipped, agents spawn as Node.js subprocesses
4. Task scheduler routes to correct runner based on mode
5. End-to-end: message -> host agent -> response (verified by human)
</verification>

<success_criteria>
- executionMode routing works in both index.ts and task-scheduler.ts
- Container mode remains fully functional (no regressions)
- Host mode produces a response from a real WhatsApp message (end-to-end)
- Startup log clearly indicates which execution mode is active
</success_criteria>

<output>
After completion, create `.planning/phases/04-runner-abstraction-and-host-runner/04-02-SUMMARY.md`
</output>
