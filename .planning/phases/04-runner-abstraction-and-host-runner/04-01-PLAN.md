---
phase: 04-runner-abstraction-and-host-runner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/host-runner.ts
  - src/group-queue.ts
autonomous: true

must_haves:
  truths:
    - "Agent-runner compiles locally via `npm run build:agent` producing container/agent-runner/dist/index.js"
    - "host-runner.ts spawns node with NANOCLAW_* env vars and reads sentinel-delimited output"
    - "Host runner has no output size truncation (unlike container runner's CONTAINER_MAX_OUTPUT_SIZE)"
    - "Host runner registers spawned process with GroupQueue via onProcess callback with null containerName"
    - "GroupQueue.registerProcess accepts string | null for containerName without type errors"
  artifacts:
    - path: "src/host-runner.ts"
      provides: "runHostAgent() function mirroring runContainerAgent() signature"
      exports: ["runHostAgent"]
    - path: "package.json"
      provides: "build:agent script for local agent-runner compilation"
      contains: "build:agent"
    - path: "container/agent-runner/dist/index.js"
      provides: "Compiled agent-runner entry point"
  key_links:
    - from: "src/host-runner.ts"
      to: "container/agent-runner/dist/index.js"
      via: "child_process.spawn with path.resolve()"
      pattern: "spawn.*node.*agent-runner"
    - from: "src/host-runner.ts"
      to: "src/container-runner.ts"
      via: "shared ContainerInput/ContainerOutput/AgentResponse types"
      pattern: "import.*ContainerInput.*container-runner"
    - from: "src/host-runner.ts"
      to: "src/group-queue.ts"
      via: "onProcess callback with null containerName"
      pattern: "onProcess.*proc.*null"
---

<objective>
Create the host-runner module and supporting infrastructure for spawning agents as native macOS subprocesses.

Purpose: This plan builds the core host-runner alongside container-runner, adds the agent-runner local build step, and fixes the GroupQueue type to accept null container names. After this plan, host-runner.ts exists and is callable but not yet wired into the app routing.

Output: `src/host-runner.ts` with `runHostAgent()`, `build:agent` npm script, compiled agent-runner dist, GroupQueue type fix.
</objective>

<execution_context>
@/Users/alvin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-runner-path-flexibility/03-01-SUMMARY.md

@src/container-runner.ts
@src/group-queue.ts
@src/config.ts
@src/config-loader.ts
@container/agent-runner/src/index.ts
@container/agent-runner/package.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Add agent-runner local build script</name>
  <files>package.json</files>
  <action>
Add a `build:agent` script to root package.json:
```json
"build:agent": "cd container/agent-runner && npm run build"
```
This compiles the agent-runner TypeScript locally so host-runner can spawn `node container/agent-runner/dist/index.js`.

After adding the script, run `npm run build:agent` to verify it produces `container/agent-runner/dist/index.js`.
  </action>
  <verify>
Run `npm run build:agent` -- must succeed and `container/agent-runner/dist/index.js` must exist.
  </verify>
  <done>
`build:agent` script exists in package.json and `npm run build:agent` produces `container/agent-runner/dist/index.js`.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Fix GroupQueue and SchedulerDependencies type signatures for null containerName</name>
  <files>src/group-queue.ts, src/task-scheduler.ts</files>
  <action>
Two type signature changes to support host mode where there is no container name:

**1. Fix GroupQueue.registerProcess to accept null containerName:**
In `src/group-queue.ts`, change the `registerProcess` method signature from:
```ts
registerProcess(groupJid: string, proc: ChildProcess, containerName: string): void
```
to:
```ts
registerProcess(groupJid: string, proc: ChildProcess, containerName: string | null): void
```

The shutdown logic at line 258 already handles the falsy case (`if (containerName)` sends `container stop`, else sends SIGTERM). This type change just makes the existing runtime behavior type-safe for host mode where there is no container name.

Also verify the `GroupState` interface's `containerName` field is already `string | null` (it should be).

**2. Fix SchedulerDependencies.onProcess callback signature:**
In `src/task-scheduler.ts`, the `SchedulerDependencies` interface has an `onProcess` callback with `containerName: string`. Change it to `containerName: string | null`.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must pass with no type errors.
Verify the signature change: `grep -n 'containerName.*string.*null' src/group-queue.ts src/task-scheduler.ts` should show both files.
  </verify>
  <done>
`GroupQueue.registerProcess` accepts `string | null` for containerName. `SchedulerDependencies.onProcess` accepts `string | null` for containerName. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create src/host-runner.ts</name>
  <files>src/host-runner.ts</files>
  <action>
Create `src/host-runner.ts` as a new module alongside `container-runner.ts`. This module spawns the agent-runner as a native Node.js subprocess instead of inside a container.

**Imports and reuse:**
- Import `ContainerInput`, `ContainerOutput`, `AgentResponse` from `./container-runner.js` (keep existing type names to avoid churn across 5+ files)
- Import `DATA_DIR`, `GROUPS_DIR`, `CONTAINER_TIMEOUT` from `./config.js`
- Import `logger` from `./logger.js`
- Import `ChildProcess`, `spawn` from `child_process`
- Import `fs`, `path`, `os` from Node.js

**Function signature:**
```ts
export async function runHostAgent(
  group: RegisteredGroup,
  input: ContainerInput,
  onProcess: (proc: ChildProcess, containerName: null) => void,
): Promise<ContainerOutput>
```
Note: `containerName` is `null` -- there is no container in host mode.

**Implementation (mirror container-runner.ts structure):**

1. **Resolve paths:**
   - `agentRunnerPath = path.resolve(process.cwd(), 'container/agent-runner/dist/index.js')`
   - Check it exists, return error ContainerOutput if not (with message suggesting `npm run build:agent`)
   - `groupDir = path.join(GROUPS_DIR, group.folder)` -- ensure it exists
   - `groupIpcDir = path.join(DATA_DIR, 'ipc', group.folder)` -- ensure messages/ and tasks/ subdirs exist
   - `globalDir = path.join(GROUPS_DIR, 'global')`
   - `homeDir = process.env.HOME || os.homedir()`

2. **Build environment variables:**
   Use an allowlist approach for the subprocess environment. Start with a filtered set from the current process:
   ```ts
   const allowedEnvVars = [
     'PATH', 'HOME', 'TERM', 'SHELL', 'USER', 'LANG', 'LC_ALL',
     'CLAUDE_CODE_OAUTH_TOKEN', 'ANTHROPIC_API_KEY', 'ANTHROPIC_MODEL',
     'CLAUDE_CODE_USE_BEDROCK', 'AWS_REGION', 'AWS_BEDROCK_CROSS_REGION',
     'AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_SESSION_TOKEN',
     'ASSISTANT_NAME',
   ];
   const env: Record<string, string> = {};
   for (const key of allowedEnvVars) {
     if (process.env[key]) env[key] = process.env[key]!;
   }
   ```

   Then add NanoClaw-specific env vars:
   ```ts
   env.NANOCLAW_MODE = 'host';
   env.NANOCLAW_GROUP_DIR = groupDir;
   env.NANOCLAW_GLOBAL_DIR = globalDir;
   env.NANOCLAW_IPC_DIR = groupIpcDir;
   env.CLAUDE_CONFIG_DIR = path.join(homeDir, '.claude');
   ```

   The user decision is to share the real `~/.claude` (not isolated per group like container mode).

3. **Spawn process:**
   ```ts
   const proc = spawn('node', [agentRunnerPath], {
     stdio: ['pipe', 'pipe', 'pipe'],
     env,
     cwd: groupDir,
   });
   ```

4. **Register with queue:**
   ```ts
   onProcess(proc, null);
   ```

5. **Send input via stdin:**
   ```ts
   proc.stdin.write(JSON.stringify(input));
   proc.stdin.end();
   ```

6. **Collect stdout and stderr WITHOUT size limits** (user decision: host mode has higher/no limits):
   - `stdout` accumulates all data from `proc.stdout`
   - `stderr` lines are logged via `logger.debug` (same pattern as container-runner)

7. **Timeout handling:**
   - Use `group.containerConfig?.timeout || CONTAINER_TIMEOUT` (same as container-runner)
   - On timeout: send SIGTERM, wait 5s grace period, then SIGKILL
   - No `container stop` -- just process signals

8. **On process close:**
   - Write log file to `groups/{folder}/logs/host-{timestamp}.log` (mirror container-runner's log pattern but prefix with `host-`)
   - Parse stdout using sentinel markers (`---NANOCLAW_OUTPUT_START---` / `---NANOCLAW_OUTPUT_END---`) -- exact same logic as container-runner
   - Return `ContainerOutput`

9. **On process error (spawn failure):**
   - Return error ContainerOutput

10. **Logging:**
    - Log at `info` level: "Spawning host agent" with group name, PID, isMain
    - Log at `debug` level: env vars being set (NANOCLAW_* only, not secrets), agent-runner path
    - Log at `info` level: "Host agent completed" with duration, status

**Key differences from container-runner:**
- No volume mounts, no container args
- No `CONTAINER_MAX_OUTPUT_SIZE` truncation on stdout/stderr
- `containerName` is `null` in onProcess callback
- Environment built via allowlist + NANOCLAW_* vars instead of env file mount
- SIGTERM/SIGKILL instead of `container stop` for timeout
- Log file prefix is `host-` instead of `container-`
  </action>
  <verify>
Run `npx tsc --noEmit` -- must pass with no type errors.
Verify `src/host-runner.ts` exports `runHostAgent`.
Verify the function accepts the same `RegisteredGroup`, `ContainerInput`, and callback pattern as `runContainerAgent`.
Verify spawn call points to correct compiled agent path: `grep -E 'spawn.*agent-runner/dist' src/host-runner.ts` must match (confirms key link host-runner -> agent-runner/dist/index.js).
  </verify>
  <done>
`src/host-runner.ts` exists with `runHostAgent()` that spawns `node container/agent-runner/dist/index.js` as a subprocess, sets NANOCLAW_* env vars, parses sentinel output, registers process with GroupQueue (null containerName), and has no output size limits. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build:agent` succeeds and `container/agent-runner/dist/index.js` exists
2. `npx tsc --noEmit` passes with no errors
3. `src/host-runner.ts` exports `runHostAgent` with matching signature pattern
4. GroupQueue.registerProcess accepts `string | null` for containerName
5. No changes to container-runner.ts (backward compatible)
</verification>

<success_criteria>
- host-runner.ts exists alongside container-runner.ts as a separate module
- Agent-runner compiles locally via build:agent script
- TypeScript compiles with no errors
- Container mode is completely unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-runner-abstraction-and-host-runner/04-01-SUMMARY.md`
</output>
